/*
 * This file is generated by jOOQ.
 */
package tech.provve.notification.db.generated.tables;


import org.jooq.*;
import org.jooq.impl.DSL;
import org.jooq.impl.Internal;
import org.jooq.impl.SQLDataType;
import org.jooq.impl.TableImpl;
import tech.provve.notification.db.generated.tables.records.NotificationsRecord;

import java.time.OffsetDateTime;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;


/**
 * This class is generated by jOOQ.
 */
@SuppressWarnings({"all", "unchecked", "rawtypes", "this-escape"})
public class Notifications extends TableImpl<NotificationsRecord> {

    private static final long serialVersionUID = 1L;

    /**
     * The reference instance of <code>notifications.notifications</code>
     */
    public static final Notifications NOTIFICATIONS_ = new Notifications();

    /**
     * The class holding records for this type
     */
    @Override
    public Class<NotificationsRecord> getRecordType() {
        return NotificationsRecord.class;
    }

    /**
     * The column <code>notifications.notifications.id</code>. Идентификатор
     * уведомления
     */
    public final TableField<NotificationsRecord, Integer> ID = createField(
            DSL.name("id"),
            SQLDataType.INTEGER.nullable(false)
                               .identity(true),
            this,
            "Идентификатор уведомления"
    );

    /**
     * The column <code>notifications.notifications.notified_account</code>.
     * Аккаунт, для которого уведомление назначено
     */
    public final TableField<NotificationsRecord, String> NOTIFIED_ACCOUNT = createField(
            DSL.name("notified_account"),
            SQLDataType.VARCHAR(50),
            this,
            "Аккаунт, для которого уведомление назначено"
    );

    /**
     * The column <code>notifications.notifications.level</code>. Уровень
     * важности уведомления: 0 - error, 1 - warning, 2 - info
     */
    public final TableField<NotificationsRecord, Short> LEVEL = createField(
            DSL.name("level"),
            SQLDataType.SMALLINT,
            this,
            "Уровень важности уведомления: 0 - error, 1 - warning, 2 - info"
    );

    /**
     * The column <code>notifications.notifications.message</code>. Содержание
     * уведомления, может содержать разметку
     */
    public final TableField<NotificationsRecord, String> MESSAGE = createField(
            DSL.name("message"),
            SQLDataType.CLOB.nullable(false),
            this,
            "Содержание уведомления, может содержать разметку"
    );

    /**
     * The column <code>notifications.notifications.created_at</code>. Время
     * создания уведомления
     */
    public final TableField<NotificationsRecord, OffsetDateTime> CREATED_AT = createField(
            DSL.name("created_at"),
            SQLDataType.TIMESTAMPWITHTIMEZONE(6)
                       .defaultValue(DSL.field(
                               DSL.raw("CURRENT_TIMESTAMP"),
                               SQLDataType.TIMESTAMPWITHTIMEZONE
                       )),
            this,
            "Время создания уведомления"
    );

    private Notifications(Name alias, Table<NotificationsRecord> aliased) {
        this(alias, aliased, (Field<?>[]) null, null);
    }

    private Notifications(Name alias, Table<NotificationsRecord> aliased, Field<?>[] parameters, Condition where) {
        super(alias, null, aliased, parameters, DSL.comment(""), TableOptions.table(), where);
    }

    /**
     * Create an aliased <code>notifications.notifications</code> table
     * reference
     */
    public Notifications(String alias) {
        this(DSL.name(alias), NOTIFICATIONS_);
    }

    /**
     * Create an aliased <code>notifications.notifications</code> table
     * reference
     */
    public Notifications(Name alias) {
        this(alias, NOTIFICATIONS_);
    }

    /**
     * Create a <code>notifications.notifications</code> table reference
     */
    public Notifications() {
        this(DSL.name("notifications"), null);
    }

    @Override
    public Schema getSchema() {
        return aliased() ? null : tech.provve.notification.db.generated.Notifications.NOTIFICATIONS;
    }

    @Override
    public Identity<NotificationsRecord, Integer> getIdentity() {
        return (Identity<NotificationsRecord, Integer>) super.getIdentity();
    }

    @Override
    public UniqueKey<NotificationsRecord> getPrimaryKey() {
        return Internal.createUniqueKey(
                Notifications.NOTIFICATIONS_,
                DSL.name("notifications_pkey"),
                new TableField[]{Notifications.NOTIFICATIONS_.ID},
                true
        );
    }

    @Override
    public List<Check<NotificationsRecord>> getChecks() {
        return Arrays.asList(
                Internal.createCheck(
                        this,
                        DSL.name("notifications_level_check"),
                        "(((level >= 0) AND (level <= 2)))",
                        true
                )
        );
    }

    @Override
    public Notifications as(String alias) {
        return new Notifications(DSL.name(alias), this);
    }

    @Override
    public Notifications as(Name alias) {
        return new Notifications(alias, this);
    }

    @Override
    public Notifications as(Table<?> alias) {
        return new Notifications(alias.getQualifiedName(), this);
    }

    /**
     * Rename this table
     */
    @Override
    public Notifications rename(String name) {
        return new Notifications(DSL.name(name), null);
    }

    /**
     * Rename this table
     */
    @Override
    public Notifications rename(Name name) {
        return new Notifications(name, null);
    }

    /**
     * Rename this table
     */
    @Override
    public Notifications rename(Table<?> name) {
        return new Notifications(name.getQualifiedName(), null);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Notifications where(Condition condition) {
        return new Notifications(getQualifiedName(), aliased() ? this : null, null, condition);
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Notifications where(Collection<? extends Condition> conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Notifications where(Condition... conditions) {
        return where(DSL.and(conditions));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Notifications where(Field<Boolean> condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Notifications where(SQL condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Notifications where(@Stringly.SQL String condition) {
        return where(DSL.condition(condition));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Notifications where(@Stringly.SQL String condition, Object... binds) {
        return where(DSL.condition(condition, binds));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    @PlainSQL
    public Notifications where(@Stringly.SQL String condition, QueryPart... parts) {
        return where(DSL.condition(condition, parts));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Notifications whereExists(Select<?> select) {
        return where(DSL.exists(select));
    }

    /**
     * Create an inline derived table from this table
     */
    @Override
    public Notifications whereNotExists(Select<?> select) {
        return where(DSL.notExists(select));
    }
}
